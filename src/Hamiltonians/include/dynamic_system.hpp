//
// Created by Panagiotis Zestanakis on 03/10/18.
//

#ifndef HAMILTONIANS_DYNAMIC_SYSTEM_HPP
#define HAMILTONIANS_DYNAMIC_SYSTEM_HPP

#include "Hamiltonian.hpp"

namespace Integrators
{
    namespace Dynamics
    {

        /// \brief dynamic_system_impl implements the dynamic system generated by the Hamiltonian Ham
        /// \tparam Ham the Hamiltonian generating the dynamic system
        /// \param direction the direction along which the normalization takes place
        /// \param s the phase space position
        /// \param dsdt the time derivatives are returned in this parameter
        template<typename Ham>
        inline Geometry::State2 dynamic_system_impl (const Ham& ham, const Geometry::State2& s)
        {
          const auto dHds = ham.derivative(s);
          return Geometry::State2{dHds.p(), -dHds.q()};
        }

        /// \brief dynamic_system_Action implements the dynamic system generated by the Hamiltonian Ham, returning also the
        /// derivative of the Action along the orbit.
        /// \tparam Ham the Hamiltonian generating the dynamic system
        /// \param direction the direction along which the normalization takes place
        /// \param s the phase space position
        /// \param dsdt the time derivatives are returned in this parameter
        template<typename Ham>
        inline Geometry::State2_Action dynamic_system_Action_impl (const Ham& ham, const Geometry::State2_Action& s)
        {
          const auto s_recuced = Geometry::State2{s.q(),s.p()};

          const auto dzdt = dynamic_system_impl(ham, s_recuced);

          const auto dJdt = s.p()*dzdt.q();

          Geometry::State2_Action ret{dzdt};
          ret.J()=dJdt;

          return ret;
        }



        /// \brief system_along_direction  normalizes the dynamic system generated by the Hamiltonian Ham so that the  normalized
        /// derivative of the quantity s' = s*direction is equal to 1.
        /// \tparam Ham the Hamiltonian type
        /// \param ham the hamiltonian
        /// \param direction the direction along which the normalization takes place
        /// \param s the phase space position
        /// \return the normalized time derivatives of the extended phase space
        ///
        /// It is assumed that direction is not perpendicular to the dynamics flow. No check is carried out for this.
        /// Otherwise, division by zero takes place. Typically direction is chosen as the vector perpendicular to a
        /// Poincare cut in phase space.
        template<typename Ham>
        inline Geometry::State2_Extended dynamic_system_along_direction_impl (const Ham& ham,
                                                                              const Geometry::State2& direction,
                                                                              const Geometry::State2_Action& s)
        {
          const Geometry::State2_Action dsdt_Action = dynamic_system_Action_impl(ham, s);

          const double  deriv_along_direction = Geometry::State2{dsdt_Action}*direction;

          Geometry::State2_Extended unnormalized_derivs{dsdt_Action};
          unnormalized_derivs.t()=1;

          return unnormalized_derivs/deriv_along_direction;
        }




        template <typename Ham>
        class DynamicSystem
        {
          Ham ham_;
         public:
          explicit DynamicSystem (Ham ham)
              : ham_(ham)
          {
          }

          Geometry::State2 dynamic_system ( const Geometry::State2& s) const noexcept
          {
            return dynamic_system_impl(ham_,s);
          }
          Geometry::State2_Action dynamic_system_Action (const Geometry::State2_Action& s) const noexcept
          {
            return dynamic_system_Action_impl(ham_,s);
          }

          Geometry::State2_Extended dynamic_system_along_direction (const Geometry::State2& direction,
                                                                    const Geometry::State2_Action& s) const noexcept
          {
            return dynamic_system_along_direction_impl(ham_,direction, s);
          }


        };

        extern template class DynamicSystem<Hamiltonian::HarmonicOscillator>;
        extern template class DynamicSystem<Hamiltonian::DuffingHamiltonian>;
    }
}

#endif //HAMILTONIANS_DYNAMIC_SYSTEM_HPP
