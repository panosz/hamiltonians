//
// Created by Panagiotis Zestanakis on 03/10/18.
//

#ifndef HAMILTONIANS_DYNAMIC_SYSTEM_HPP
#define HAMILTONIANS_DYNAMIC_SYSTEM_HPP

#include "Hamiltonian.hpp"

namespace Integrators
{
    namespace Dynamics
    {

        /// \brief system implements the dynamic system generated by the Hamiltonian Ham
        /// \tparam Ham the Hamiltonian generating the dynamic system
        /// \param direction the direction along which the normalization takes place
        /// \param s the phase space position
        /// \param dsdt the time derivatives are returned in this parameter
        template<typename Ham>
        void system (const Geometry::State2& s, Geometry::State2& dsdt, double /*t*/)
        {
          const auto dHds = Ham().derivative(s);
          dsdt = Geometry::State2(dHds.p(), -dHds.q());
        }

        /// \brief SystemAlongDirection normalizes the dynamic system generated by the Hamiltonian Ham so that the  normalized
        /// derivative of the quantity s' = s*direction is equal to 1.
        /// \tparam Ham the Hamiltonian generating the dynamic system
        ///
        /// It is assumed that direction is not perpendicular to the dynamics flow. No check is carried out for this.
        /// Otherwise, division by zero takes place. Typically direction is chosen as the vector perpendicular to a
        /// Poincare cut in phase space.
        template<typename Ham>
        class
        SystemAlongDirection {
         private :
          Geometry::State2 direction_;

         public:
          ///
          /// \param direction the direction along which the normalization takes place
          explicit SystemAlongDirection (const Geometry::State2& direction) noexcept
              : direction_{direction}
          { };

          /// calculate the normalized time derivatives
          /// \param s the phase space position
          /// \param dsdt the time derivatives are returned in this parameter
          /// \param t time
          void operator() (const Geometry::State2& s, Geometry::State2& dsdt, double t) const
          {

            system<Ham>(s, dsdt, t);
            dsdt /= dsdt * direction_;

          };
        };
    }
}

#endif //HAMILTONIANS_DYNAMIC_SYSTEM_HPP
