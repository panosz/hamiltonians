//
// Created by Panagiotis Zestanakis on 03/10/18.
//

#ifndef HAMILTONIANS_DYNAMIC_SYSTEM_HPP
#define HAMILTONIANS_DYNAMIC_SYSTEM_HPP

#include "Hamiltonian.hpp"

namespace Integrators
{
    namespace Dynamics
    {

        /// \brief dynamic_system implements the dynamic system generated by the Hamiltonian Ham
        /// \tparam Ham the Hamiltonian generating the dynamic system
        /// \param direction the direction along which the normalization takes place
        /// \param s the phase space position
        /// \param dsdt the time derivatives are returned in this parameter
        template<typename Ham>
        inline Geometry::State2 dynamic_system (const Ham& ham, const Geometry::State2& s)
        {
          const auto dHds = ham.derivative(s);
          return Geometry::State2{dHds.p(), -dHds.q()};
        }

        /// \brief dynamic_system_Action implements the dynamic system generated by the Hamiltonian Ham, returning also the
        /// derivative of the Action along the orbit.
        /// \tparam Ham the Hamiltonian generating the dynamic system
        /// \param direction the direction along which the normalization takes place
        /// \param s the phase space position
        /// \param dsdt the time derivatives are returned in this parameter
        template<typename Ham>
        inline Geometry::State2_Action dynamic_system_Action (const Ham& ham, const Geometry::State2_Action& s)
        {
          const auto s_recuced = Geometry::State2{s.q(),s.p()};

          const auto dzdt = dynamic_system(ham,s_recuced);

          const auto dJdt = s.p()*dzdt.q();

          Geometry::State2_Action ret{dzdt};
          ret.J()=dJdt;

          return ret;
        }



        /// \brief system_along_direction  normalizes the dynamic system generated by the Hamiltonian Ham so that the  normalized
        /// derivative of the quantity s' = s*direction is equal to 1.
        /// \tparam Ham the Hamiltonian type
        /// \param ham the hamiltonian
        /// \param direction the direction along which the normalization takes place
        /// \param s the phase space position
        /// \return the normalized time derivatives of the extended phase space
        ///
        /// It is assumed that direction is not perpendicular to the dynamics flow. No check is carried out for this.
        /// Otherwise, division by zero takes place. Typically direction is chosen as the vector perpendicular to a
        /// Poincare cut in phase space.
        template<typename Ham>
        inline Geometry::State2_Extended dynamic_system_along_direction (const Ham& ham,
                                                                         const Geometry::State2& direction,
                                                                         const Geometry::State2_Action& s)
        {
          const Geometry::State2_Action dsdt_Action = dynamic_system_Action(ham, s);

          const double  deriv_along_direction = Geometry::State2{dsdt_Action}*direction;

          Geometry::State2_Extended unnormalized_derivs{dsdt_Action};
          unnormalized_derivs.t()=1;

          return unnormalized_derivs/deriv_along_direction;
        }

//        /// \brief SystemAlongDirection
//        /// \tparam Ham the Hamiltonian generating the dynamic system
//        ///
//        /// It is assumed that direction is not perpendicular to the dynamics flow. No check is carried out for this.
//        /// Otherwise, division by zero takes place. Typically direction is chosen as the vector perpendicular to a
//        /// Poincare cut in phase space.
//        template<typename Ham>
//        class
//        SystemAlongDirection {
//         private :
//          Ham ham_;
//          Geometry::State2 direction_;
//
//         public:
//          ///
//          /// \param direction
//          explicit SystemAlongDirection (Ham ham,const Geometry::State2& direction) noexcept
//              : ham_{std::move(ham)}, direction_{direction}
//          { };
//
//          /// calculate the normalized time derivatives
//          /// \param s the phase space position
//          /// \param dsdt the time derivatives are returned in this parameter
//          /// \param t time
//          inline void  operator() (const Geometry::State2_Extended& s_extended, Geometry::State2_Extended& dsdt_extended, double t) const
//          {
//
//            Geometry::State2 s{s_extended};
//            dsdt_extended = dynamic_system_along_direction(ham_, direction_, s);
//
//          };
//        };
    }
}

#endif //HAMILTONIANS_DYNAMIC_SYSTEM_HPP
